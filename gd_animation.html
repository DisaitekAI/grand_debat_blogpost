<!DOCTYPE html>
<html>
    <head>
        <!-- Load D3 from site -->
        <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    </head>

    <!-- CSS (Styling) -->
    <style type="text/css">
     /* Format X and Y Axis */
     .axis path,
     .axis line {
         fill: none;
         stroke: black;
         shape-rendering: crispEdges;
     }

     .axis text {
         font-family: sans-serif;
         font-size: 11px;
     }

     .dot {
         stroke: none;
     }

     .tooltip {
         position: absolute;
         font-size: 12px;
         width:  auto;
         height: auto;
         pointer-events: none;
         background-color: white;
     }
    </style>
    <!-- End CSS (Styling) -->

    <body>
        <h2>D3 Scatterplot </h2>
        <p>This is a data visualization using transitions with a scatterplot</p>
        <h4>Click on this text to update chart with new values</h4>
        <div id="vis-container"></div>

        <!-- Begin D3 Javascript -->
        <script type="text/javascript">
         d3.csv('./gd_animation_subset.csv', function loadCallback(error, data) {
             data.forEach(function(d){
                 d.x      = +d.x;
                 d.y      = +d.y;
                 d.init_x = +d.init_x;
                 d.init_y = +d.init_y;
             });
             makeViz(data);
         });

         var colorScale    = d3.scale.category10();
         var dotRadius     = 3;
         var dotRadiusAnim = 5;
         var makeViz = function(dataset) {
             // Setup settings for graphic
             var canvasWidth  = 1000;
             var canvasHeight = 600;
             var padding      = 30;  // for chart edges

             // Create scale functions
             var xScale = d3.scale.linear()  // xScale is width of graphic
                            .domain([
                                d3.min(dataset, function(d) {
                                    return d.init_x;  // input domain
                                }),
                                d3.max(dataset, function(d) {
                                    return d.init_x;  // input domain
                                })
                            ])
                            .range([padding, canvasWidth - padding * 2]); // output range

             var yScale = d3.scale.linear()  // yScale is height of graphic
                            .domain([
                                d3.min(dataset, function(d) {
                                    return d.init_y;  // input domain
                                }),
                                d3.max(dataset, function(d) {
                                    return d.init_y;  // input domain
                                })
                            ])
                            .range([canvasHeight - padding, padding]);  // remember y starts on top going down so we flip

             // Define X axis
             var xAxis = d3.svg.axis()
                           .scale(xScale)
                           .orient("bottom")
                           .ticks(5);

             // Define Y axis
             var yAxis = d3.svg.axis()
                           .scale(yScale)
                           .orient("left")
                           .ticks(5);
             // Create SVG element
             var svg = d3.select("#vis-container")  // This is where we put our vis
                         .append("svg")
                         .attr("width", canvasWidth)
                         .attr("height", canvasHeight)
                         .append("g");

             // Create tooltip for mouseover
             var tooltip = d3.select("#vis-container")
                             .append("div")
                             .attr("class", "tooltip")
                             .style("opacity", 0.5);

             var tipMouseover = function(d) {
                 console.log(d.comment);
                 /* var html = "<b>" + d.comment + "</b>";

                  * tooltip.html(html)
                  *        .style("left", (d3.event.pageX + 15) + "px")
                  *        .style("top", (d3.event.pageY - 28) + "px")
                  *        .transition()
                  *        .duration(200)
                  *        .style("opacity", .9); */
             };

             var tipMouseout = function(d) {
                 console.log(d.comment);
                 /* tooltip.transition()
                  *        .duration(300)
                  *        .style("opacity", 0); */
             };

             // Create Circles
             svg.selectAll(".dot")
                .data(dataset)
                .enter()
                .append("circle")
                .attr("class", "dot")
                .attr("cx", function(d) {
                    return xScale(d.init_x);  // Circle's X
                })
                .attr("cy", function(d) {  // Circle's Y
                    return yScale(d.init_y);
                })
                .attr("r", dotRadius)  // radius
                .on("mouveover", tipMouseover)
                .on("mouveout", tipMouseout);

             /* svg.selectAll("circle")
              *    .data(dataset)
              *    .enter()
              *    .append("circle")  // Add circle svg
              *    .attr("cx", function(d) {
              *        return xScale(d.init_x);  // Circle's X
              *    })
              *    .attr("cy", function(d) {  // Circle's Y
              *        return yScale(d.init_y);
              *    })
              *    .attr("r", dotRadius)  // radius
              *    .on("mouveover", tipMouseover)
              *    .on("mouveout", tipMouseout);
              */

             // Add to X axis
             svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + (canvasHeight - padding) +")")
                .call(xAxis);

             // Add to Y axis
             svg.append("g")
                .attr("class", "y axis")
                .attr("transform", "translate(" + padding +",0)")
                .call(yAxis);

             // On click, update with new data
             d3.select("h4")
               .on("click", function() {
                   // Update scale domains
                   xScale.domain([
                       d3.min(dataset, function(d) {
                           return d.x;
                       }),
                       d3.max(dataset, function(d) {
                           return d.x;
                       })]
                   );
                   yScale.domain([
                       d3.min(dataset, function(d) {
                           return d.y;
                       }),
                       d3.max(dataset, function(d) {
                           return d.y;
                       })
                   ]);

                   // Update circles
                   svg.selectAll("circle")
                      .data(dataset)  // Update with new data
                      .transition()  // Transition from old to new
                      .duration(1000)  // Length of animation
                      .each("start", function() {  // Start animation
                          d3.select(this)  // 'this' means the current element
                            .attr("fill", "red")  // Change color
                            .attr("r", dotRadiusAnim);  // Change size
                      })
                      .delay(function(d, i) {
                          return i / dataset.length * 500;  // Dynamic delay (i.e. each item delays a little longer)
                      })
                   // .ease("bounce")  // Transition easing - default 'variable' (i.e. has acceleration), also: 'circle', 'elastic', 'bounce', 'linear' 
                      .attr("cx", function(d) {
                          return xScale(d.x);  // Circle's X
                      })
                      .attr("cy", function(d) {
                          return yScale(d.y);  // Circle's Y
                      })
                      .each("end", function() {  // End animation
                          d3.select(this)  // 'this' means the current element
                            .transition()
                            .duration(500)
                            .attr("fill", function(d) {
                                return colorScale(d.cluster_name);
                            })
                            .attr("r", dotRadius);  // Change radius
                      });
                   // .attr("fill", "black")  // Change color 

                   // Update X Axis
                   svg.select(".x.axis")
                      .transition()
                      .duration(1000)
                      .call(xAxis);

                   // Update Y Axis
                   svg.select(".y.axis")
                      .transition()
                      .duration(100)
                      .call(yAxis);
               });

         };
        </script>
    </body>
</html>
